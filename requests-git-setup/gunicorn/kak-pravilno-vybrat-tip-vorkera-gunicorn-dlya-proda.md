# Как правильно выбрать тип воркера Gunicorn для прода

{% hint style="info" %}
Ссылка на оригинальную статью: [How to choose the right Gunicorn Worker Type for production](https://luis-sena.medium.com/gunicorn-worker-types-youre-probably-using-them-wrong-381239e13594)

Опубликовано: 25 января 2021

Авторы: [Luis Sena](https://luis-sena.medium.com/?source=post\_page-----381239e13594--------------------------------)
{% endhint %}

<figure><img src="../../.gitbook/assets/gunicorn-5.webp" alt=""><figcaption></figcaption></figure>

> В этой статье предполагается, что вы используете синхронный фреймворк, такой как flask или Django, и не рассматривается возможность использования шаблона async/await.

Во-первых, давайте кратко обсудим, как Python обрабатывает параллелизм и параллелизм.

Python никогда не запускает более одного потока на процесс из-за GIL.

Даже если в вашем процессе 100 потоков, GIL позволит одновременно выполнять только один поток. Это означает, что в любой момент 99 из этих потоков приостановлены, а 1 поток работает. За эту оркестровку отвечает GIL.

Чтобы обойти это ограничение, мы можем использовать Gunicorn. Из документов:

> Gunicorn основан на pre-fork модели воркера. Это означает, что существует центральный главный процесс, который управляет набором рабочих процессов. Мастер никогда ничего не знает об отдельных клиентах. Все запросы и ответы полностью обрабатываются рабочими процессами.

Это означает, что Gunicorn создаст указанное количество отдельных процессов и загрузит ваше приложение в каждый процесс/воркер, обеспечивая параллельную обработку вашего приложения Python.

Поскольку один размер никогда не будет соответствовать потребностям всех, он предлагает разные типы воркеров, чтобы удовлетворить более широкий спектр вариантов использования.

## sync

Это рабочий класс по умолчанию. Каждый процесс будет обрабатывать по одному запросу за раз, и вы можете использовать параметр `-w` для установки рабочих процессов.

Рекомендуемое количество воркеров — `2–4 x $(NUM_CORES)`, хотя это будет зависеть от того, как работает ваше приложение.

Когда использовать:

* Ваша работа почти полностью связана с процессором;
* Операции ввода-вывода от низкого до нуля (включая доступ к базе данных, сетевые запросы и т. д.).

Признаки, на которые стоит обратить внимание на проде:

Отслеживайте загрузку ЦП и входящие запросы, чтобы убедиться, что среднее количество процессов соответствует размеру вашего компьютера, а также шаблоны запросов.

Если у вас слишком много процессов, это может замедлить среднюю задержку, поскольку в процессоре вашего компьютера будет происходить много переключений контекста.

Если вы видите много ошибок тайм-аута между вашим обратным прокси-сервером (например, nginx), это признак того, что у вас недостаточно параллелизма для обработки шаблонов трафика/нагрузки.

## gthread

{% hint style="info" %}
Если вы попытаетесь использовать тип рабочего процесса sync и установите для параметра потоков значение более 1, вместо него будет использоваться тип рабочего процесса gthread.
{% endhint %}

Если вы используете gthread, Gunicorn позволит каждому воркеру иметь несколько потоков. В этом случае приложение Python загружается один раз для каждого рабочего процесса, и каждый из потоков, созданных одним и тем же рабочим процессом, использует одно и то же пространство памяти.

Эти потоки будут зависеть от GIL, но он по-прежнему полезен, когда у вас происходит блокировка ввода-вывода. Это позволит вам обрабатывать больше параллелизма без слишком большого увеличения памяти.

Рекомендуемое общее количество параллельных запросов осталось прежним. Вероятно, это наиболее часто используемая конфигурация, которую вы встретите в реальной жизни.

Когда использовать:

* Умеренные операции ввода-вывода;
* Умеренная загрузка процессора;
* Вы используете пакеты/расширения, которые не исправлены для асинхронной работы, и/или не можете исправить их самостоятельно.

Признаки, на которые стоит обратить внимание при производстве:

Те, которые я описала для типа воркера sync.

…с оговоркой о балансе между процессами и потоками. Этот баланс будет во многом зависеть от ваших моделей использования.

## eventlet / gevent

Eventlet и gevent используют «зеленые потоки» или «псевдопотоки» и основаны на [greenlet](https://greenlet.readthedocs.io/en/latest/).

На практике, если работа вашего приложения в основном связана с вводом-выводом, это позволит ему масштабироваться потенциально до тысяч одновременных запросов в одном процессе.

Даже с появлением асинхронных фреймворков (fastapi, sanic и т. д.) это по-прежнему актуально сегодня, поскольку позволяет оптимизировать ввод-вывод без дополнительной сложности кода.

Им удается это сделать путем «[обезьяньего исправления](https://en.wikipedia.org/wiki/Monkey\_patch)» вашего кода, в основном заменяя блокирующие части совместимыми совместными аналогами из пакета gevent.

Он использует epoll, kqueue или libevent для масштабируемого неблокирующего ввода-вывода. Сопрограммы гарантируют, что разработчик использует блокирующий стиль программирования, аналогичный многопоточности, но предоставляющий преимущества неблокирующего ввода-вывода.

Обычно это наиболее эффективный способ запуска вашего веб-приложения django/flask/etc, поскольку большую часть времени основная задержка возникает из-за работы, связанной с вводом-выводом.

При этом может быть сложно настроить его на 100% правильно, и если вы не обслуживаете сотни или более запросов в секунду, вероятно, проще просто использовать рабочий класс gthread.

Признаки, на которые стоит обратить внимание при производстве:

* Убедитесь, что все части вашего кода взаимодействуют с этими асинхронными платформами (например, правильно исправлены). Без этого вы могли бы заблокировать потоки, которые простаивают и не смогут выполнять работу (например, принимать новые запросы и отвечать на ранее принятые запросы, которые завершили вызов ввода-вывода). Если в рабочей среде загрузка вашего ЦП низкая, но в журналах nginx вы видите много таймаутов, велика вероятность, что это происходит. Но вам следует проверить это перед развертыванием в рабочей среде. (Я опишу, как с этим справиться, позже в этом посте).
* Подключения к вашим базам данных. Если у вас тысячи одновременных подключений и вы используете СУБД, такую как PostgreSQL, без пула соединений, скорее всего, вам придется плохо (я опишу, как справиться с этим позже в этом посте).

## tornado

Еще есть рабочий класс Tornado. Его можно использовать для написания приложений с использованием фреймворка Tornado. Хотя рабочие Tornado способны обслуживать приложение WSGI, это не рекомендуемая конфигурация.

## Советы и рекомендации по использованию типов работников "green thread"

> Я сосредоточусь на [gevent](http://www.gevent.org/intro.html), а не на eventlet, поскольку он стал популярным выбором.

Убедитесь, что все в вашем проекте дружелюбно к событиям. Сюда входят пакеты и драйверы. Я перечислю некоторые из наиболее часто используемых пакетов и расскажу, как их исправить, если это необходимо.

### PostgreSQL

Официальный пакет psycopg2, но он не подготовлен для исправления gevent. Вам также понадобится [psycogreen](https://github.com/psycopg/psycogreen/?source=post\_page-----381239e13594--------------------------------).

### MySQL

Рекомендуемый пакет — [PyMySQL](https://github.com/PyMySQL/PyMySQL?source=post\_page-----381239e13594--------------------------------), он поддерживает gevent.

### Redis

Рекомендуемый пакет — [redis-py](https://github.com/andymccurdy/redis-py?source=post\_page-----381239e13594--------------------------------), дружественный к gevent.

### MongoDB

Рекомендуемый пакет — [PyMongo](https://github.com/mongodb/mongo-python-driver?source=post\_page-----381239e13594--------------------------------), он совместим с gevent.

### Elasticsearch

Рекомендуемый пакет – [elasticsearch-py](https://github.com/elastic/elasticsearch-py?source=post\_page-----381239e13594--------------------------------), дружественный к gevent. Цитата сопровождающего:

> Сама библиотека просто передает все, что возвращается из класса соединения. По умолчанию он использует стандартные сокеты (через urllib3), поэтому его можно сделать совместимым с помощью обезьяньего исправления. Альтернативно вы можете создать свой собственный connection\_class и подключить его.

### Cassandra

Рекомендуемый пакет взят из [datastax](https://github.com/datastax/python-driver?source=post\_page-----381239e13594--------------------------------) и совместим с gevent.

### Пул соединений

При использовании gevent следует учитывать одну вещь: понимать, что очень легко получить множество одновременных подключений, например, к вашей базе данных. Для некоторых СУБД, таких как PostgreSQL, это может быть очень опасно. Стандартной практикой в таких случаях является использование пула соединений. В случае с PostgreSQL очень хорошо подойдет фреймворк SQLAlchemy или PgBouncer.

### Мониторинг заблокированных потоков

Очень важно убедиться, что части вашего кода не блокируют возврат greenlet в хаб.

К счастью, начиная с версии gevent 1.3, мониторинг упрощается с помощью свойства monitor\_thread, и вы можете включить его в своих модульных тестах:

{% hint style="info" %}
[Глобальная конфигурация для gevent.](http://www.gevent.org/configuration.html?source=post\_page-----381239e13594--------------------------------#gevent.\_config.Config.monitor\_thread)

[В gevent.config есть один экземпляр этого объекта. Если вы собираетесь вносить изменения в код, то вместо использования документированных переменных среды вам необходимо внести изменения перед использованием каких-либо частей gevent, которым могут потребоваться эти настройки. Например:](http://www.gevent.org/configuration.html?source=post\_page-----381239e13594--------------------------------#gevent.\_config.Config.monitor\_thread)
{% endhint %}

Также неплохо включить его в вашей среде разработки, поскольку некоторые блоки могут быть пропущены во время CI-прогонов, поскольку некоторые элементы ввода-вывода обычно имитируются.

## Выводы

* gunicorn/wsgi по-прежнему остается приемлемым выбором даже с появлением асинхронных фреймворков, таких как fastapi и sanic;
* gthread обычно является предпочтительным типом рабочего процесса для многих из-за его простоты настройки в сочетании с возможностью масштабирования параллелизма без чрезмерного раздувания памяти;
* gevent — лучший выбор, когда вам нужен параллелизм и большая часть вашей работы связана с вводом-выводом (сетевые вызовы, доступ к файлам, базы данных и т. д.).

## Дальнейшее чтение

[Понимание и оптимизация многопроцессного управления памятью Python](https://luis-sena.medium.com/understanding-and-optimizing-python-multi-process-memory-management-24e1e5e79047).

Как все это звучит? Есть ли что-то, что вы хотели бы, чтобы я подробно рассказал? Дайте мне знать ваши мысли в разделе комментариев ниже (и нажмите аплодисменты, если это было полезно)!

Оставайтесь с нами для следующего поста. Следите, чтобы не пропустить!
