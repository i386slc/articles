# from dynaconf import settings

{% hint style="info" %}
Ссылка на оригинальную статью: [from dynaconf import settings](https://dev.to/rochacbruno/from-dynaconf-import-settings-2f8o)

Опубликовано: 12 апреля 2019

Авторы: [Bruno Rocha](https://dev.to/rochacbruno)
{% endhint %}

Часто при запуске нового проекта Python нам нужно потратить некоторое время на размышления о том, как управлять настройками, решить, для какого модуля будет написан менеджер конфигурации, решить, какое имя дать этому модулю, создать класс или функцию для хранения конфигурационных ключей, создать условия для нескольких сред и все еще нужно беспокоиться о том, где эти ключи будут храниться и в каком формате файла?

Больше не надо! теперь у вас есть [Dynaconf](http://github.com/rochacbruno/dynaconf)!

Потратьте свое драгоценное время на разработку своего приложения, запустите `pip install dynaconf` и позвольте Dynaconf позаботиться о ваших настройках.

## Быстрый старт

```bash
from dynaconf import settings
```

Вот и все!

Это единственная строка кода, которая вам нужна, без сложного шаблона, без [hadouken-ifs](https://i.imgur.com/rxxTUoe.jpg), без необходимости поддерживать классы конфигурации.

Вы, должно быть, задаетесь вопросом: **«Что это за магия? Откуда берутся значения настроек?»**

Что ж, никакого волшебства нет, и значения могут поступать откуда угодно, по умолчанию и в соответствии с рекомендациями [12-факторных приложений](https://dev.to/rochacbruno/from-dynaconf-import-settings-2f8o) Dynaconf отдает предпочтение переменным среды.

```bash
# опционально можно сохранить в файле .env
export DYNACONF_DEBUG=true
export DYNACONF_NAME=Bruno
```

```python
# app.py
from dynaconf import settings
if settings.DEBUG is True:
    print(settings.NAME)
```

```bash
$ python3 app.py
Bruno
```

> Переменные окружения для Dynaconf набираются в формате **toml**, поэтому значение **true** оценивается как логическое значение `True`, что позволяет экспортировать списки, словари, числа с плавающей запятой, логические значения и т. д.

[Подробнее о envvars](https://dynaconf.readthedocs.io/en/latest/guides/environment\_variables.html)

## Больше, чем переменные среды

Что ж, это круто, но в вашем проекте не будет настроек, исходящих только от переменных среды, я уверен, что вы хотите иметь файл настроек, в котором вы можете установить значения по умолчанию.

Dynaconf может читать несколько форматов файлов, из коробки он поддерживает `.py`, `.toml`, `.ini` и `.json`. Если установлен **PyYAML**, он также будет поддерживать `.yaml`, и вам не нужно заботиться о поиске и открытии файлов. Предпочтительным форматом является `.toml`, потому что в настоящее время это лучший формат конфигурации, широко распространенный, и вы можете использовать любой формат файла, который вы хотите.

```toml
# settings.toml
[default]
name = "Bruno"

[development]
debug = true

[production]
debug = false
```

```python
# app.py
from dynaconf import settings
if settings.DEBUG is True:
    print(settings.NAME)
```

```bash
$ python3 app.py
Bruno
```

И как вы можете видеть сейчас, используя файл настройки `settings.`, у нас могут быть отдельные `[environments]` по умолчанию, dynaconf всегда будет работать над `[development]`, что означает, что будут загружены только переменные `[default]` и `[development]`. В любое время вы можете выполнить `export ENV_FOR_DYNACONF=production`, после чего он начнет использовать значения из среды `[production]`.

> Если вы не хотите иметь такое разделение по средам, вы можете просто поместить все в раздел `[default]`.

[Подробнее о файлах сред и настроек](https://dynaconf.readthedocs.io/en/latest/guides/usage.html#working-environments)

## Некоторые значения являются секретами

Хорошей практикой является не хранить ваши секреты **secrets**, такие как **пароли и токены**, непосредственно в файлах настроек, потому что вы можете сделать ошибку и зафиксировать это в общедоступном репозитории git, поэтому есть несколько альтернатив для хранения **secrets**.

### Переменные среды

> Не рекомендуется

Есть некоторые люди, которые [не согласны](https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/), и это действительно точка отказа безопасности. Впрочем, если вы уверены, что ваша машина защищена, то можете оставить секреты в переменных, на свой страх и риск Dynaconf сможет нормально прочитать.

### Секретные файлы

Это простой уровень безопасности для хранения секретов, особенно полезно хранить секреты разработки. Этот **токен** вы используете для доступа к API разработки и т. д.

Это очень просто: вместе с вашим обычным файлом `settings.toml` вы помещаете новый файл с именем `.secrets.toml` и сохраняете там свои конфиденциальные данные. Dynaconf прочитает его после чтения `settings.toml`.

Подождите... как это решает мою проблему с безопасностью?

Ну, это не так (пока), но это облегчает вашу жизнь двумя способами.

1. Поместите `.secrets.*` в ваш `~/.gitignore`, чтобы вы никогда не совершили ошибку, отправив эти данные в общедоступный репозиторий git.
2. Dynaconf может выводить отладочную информацию, когда `DEBUG_LEVEL_FOR_DYNACON=DEBUG` экспортируется, печатаются все загруженные значения, но если значения поступают из файла `.secrets.*`, то печатается только ключ, а значение маскируется. Полезно использовать на публичных CI.
3. Вы можете настроить шаг в своем плейбуке развертывания **Ansible**, который будет безопасно копировать или генерировать файл секретов для хранения в вашей производственной среде.

Вы также можете указать Dynaconf загрузить этот файл откуда-то еще, если:

```bash
export SECRETS_FOR_DYNACONF=/path/to/secrets/location/.secrets.yaml
```

(очень полезно для CI, таких как Jenkins)

### Проект Vault от Hashicorp

> Рекомендуем!

Теперь мы действительно говорим о **настоящей безопасности**.

Использование **Vault** — лучший способ защитить ваши секреты. dynaconf имеет встроенную поддержку:

```bash
export VAULT_ENABLED_FOR_DYNACONF=true
export VAULT_URL_FOR_DYNACONF=https://..../
export OTHER_VAULT_CONFIGS
```

И затем, если, например, на вашем сервере хранилища сохранен **TOKEN**, вы можете просто сделать:

```python
from dynaconf import settings
perform_your_authentication(settings.TOKEN)
```

Vault имеет множество функций, таких как аренда и запечатанные хранилища.

[Читать далее](https://dynaconf.readthedocs.io/en/latest/guides/sensitive\_secrets.html).

## Вы используете Django или Flask?

Dynaconf предоставляет расширения для этих двух фреймворков, с помощью двух строк кода вы включаете его, и тогда ваш фреймворк начнет считывать настройки из Dynaconf.

### Django

```python
# settings.py
import dynaconf  # noqa
settings = dynaconf.DjangoDynaconf(__name__, **options)
```

Теперь, если вы делаете `export DJANGO_FOO=BAR`, вы можете получить доступ к своему приложению через `django.conf.settings.FOO`.

[Читать далее](https://dynaconf.readthedocs.io/en/latest/guides/django.html).

### Flask

```python
# app.py
from dynaconf import FlaskDynaconf
FlaskDynaconf(app, **options)
```

Теперь, если вы делаете `export FLASK_FOO=BAR`, вы можете получить доступ к своему приложению через `app.config['FOO']`.

[Читать далее](https://dynaconf.readthedocs.io/en/latest/guides/flask.html).

### Что делать, если вы используете другой формат файла настроек? другой фреймворк и другое внешнее хранилище?

> Вы можете расширять Dynaconf, добавляя новые загрузчики!

Dynaconf уже предоставляет загрузчики для:

* `.py`
* `.json`
* `.yaml`
* `.toml`
* `.ini`
* Сервер Redis
* Сервер Vault
* `.env` файлы
* Переменные среды

Но если это не подходит для вашего проекта, вы все равно можете [создать свой собственный загрузчик](https://dynaconf.readthedocs.io/en/latest/guides/extend.html).

## Заключение

* Хорошо протестировано
* Нам доверяют такие компании, как Red Hat, Seek, Catho и другие.
* Хорошо протестировано как в среде Linux, так и в среде Windows
* Строгое отделение настроек от кода (в соответствии с Руководством по [12-факторным приложениям](https://12factor.net/config)).
* Определяет исчерпывающие значения по умолчанию.
* Хранит параметры в нескольких форматах файлов (**.toml**, `.json`, `.yaml`, `.ini` и `.py`).
* Конфиденциальные секреты **secrets**, такие как токены и пароли, можно хранить в безопасных местах, таких как файл `.secrets` или сервер хранилища Vault.
* При желании параметры могут храниться во внешних службах, таких как сервер Redis.
* Простая система **флагов функций**.
* Многоуровневая `[environment]` система.
* Переменные среды можно использовать для переопределения параметров.
* Поддержка файлов `.env` для автоматизации экспорта переменных среды.
* Правильные типы данных (даже для переменных среды).
* Имейте **только один** модуль канонических настроек, чтобы управлять всеми вашими экземплярами.
* Добавьте расширение для объекта **Flask** `app.config`.
* Добавьте расширение для объекта **Django** `conf.settings`.
* Мощный интерфейс командной строки **$ dynaconf**, который поможет вам управлять настройками через консоль.
* Настраиваемая система проверки **Validation** для обеспечения правильных параметров конфигурации.
* Разрешает изменение динамических (**dyna**) параметров на лету без необходимости повторного развертывания приложения.

## Читать документацию

> Настройки просты, но Dynaconf предоставляет еще больше функций, таких как **флаги функций**, **менеджеры контекста настроек**, **настройки плагинов** и т. д.

Документация: [https://www.dynaconf.com/](https://www.dynaconf.com/)

Dynaconf ждет ваших [отзывов](https://github.com/rochacbruno/dynaconf/issues/155) и [предложений](https://github.com/rochacbruno/dynaconf/issues).

```python
from dynaconf import settings
settings.THANKS_FOR_READING
```
