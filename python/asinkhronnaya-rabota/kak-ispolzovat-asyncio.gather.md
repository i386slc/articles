# Как использовать asyncio.gather()

{% hint style="info" %}
Ссылка на оригинальную статью: [How to Use asyncio.gather() in Python](https://superfastpython.com/asyncio-gather/)

Опубликовано: 20 ноября 2022

Последнее обновление: 23 ноября 2022

Авторы:  [Jason Brownlee](https://superfastpython.com/about)
{% endhint %}

Нам нужны способы работы с наборами задач таким образом, чтобы их можно было рассматривать как группу.

Функция модуля asyncio.gather() предоставляет эту возможность и возвращает итерацию возвращаемых значений из ожидаемых запросов.

В этом руководстве вы узнаете, как ожидать выполнения задач asyncio одновременно с asyncio.gather().

После завершения этого урока вы будете знать:

* Что функция asyncio.gather() будет ждать завершения набора задач и получить все возвращаемые значения.
* Как использовать asyncio.gather() с коллекциями сопрограмм и коллекциями задач.
* Как использовать asyncio.gather() для создания вложенных групп задач, которые можно ожидать и отменять.

Давайте начнем.

## Оглавление

1. [Что такое Asyncio gather()](kak-ispolzovat-asyncio.gather.md#id-1.-chto-takoe-asyncio-gather)
2. [Как использовать Asyncio gather()](kak-ispolzovat-asyncio.gather.md#id-2.-kak-ispolzovat-asyncio-gather)
   * [gather() принимает задачи и сопрограммы](kak-ispolzovat-asyncio.gather.md#id-2.1.-gather-prinimaet-zadachi-i-soprogrammy)
   * [gather() возвращает объекты Future](kak-ispolzovat-asyncio.gather.md#id-2.2.-gather-vozvrashaet-obekty-future)
   * [В ожидании объекта Future метода gather()](kak-ispolzovat-asyncio.gather.md#id-2.3.-v-ozhidanii-obekta-future-metoda-gather)
   * [gather() может вкладывать группы ожидаемых объектов](kak-ispolzovat-asyncio.gather.md#id-2.4.-gather-mozhet-vkladyvat-gruppy-ozhidaemykh-obektov)
   * [gather() и исключения](kak-ispolzovat-asyncio.gather.md#id-2.5.-gather-i-isklyucheniya)
   * [объект Future метода gather() может быть отменен](kak-ispolzovat-asyncio.gather.md#id-2.6.-obekt-future-metoda-gather-mozhet-byt-otmenen)
3. [Примеры gather() с сопрограммами](kak-ispolzovat-asyncio.gather.md#id-3.-primery-gather-s-soprogrammami)
   * [Пример gather() для одной сопрограммы](kak-ispolzovat-asyncio.gather.md#id-3.1.-primer-gather-dlya-odnoi-soprogrammy)
   * [Пример gather() для множества сопрограмм](kak-ispolzovat-asyncio.gather.md#id-3.2.-primer-gather-dlya-mnozhestva-soprogramm)
   * [Пример gather() для множества сопрограмм в списке](kak-ispolzovat-asyncio.gather.md#id-3.3.-primer-gather-dlya-mnozhestva-soprogramm-v-spiske)
   * [Пример метода gather() с возвращаемыми значениями](kak-ispolzovat-asyncio.gather.md#id-3.4.-primer-metoda-gather-s-vozvrashaemymi-znacheniyami)
   * [Пример gather() с вложенными группами](kak-ispolzovat-asyncio.gather.md#id-3.5.-primer-gather-s-vlozhennymi-gruppami)
   * [Пример сочетания задач и сопрограмм с помощью метода gather()](kak-ispolzovat-asyncio.gather.md#id-3.6.-primer-sochetaniya-zadach-i-soprogramm-s-pomoshyu-metoda-gather)
4. [Примеры gather() с ошибками](kak-ispolzovat-asyncio.gather.md#id-4.-primery-gather-s-oshibkami)
   * [Пример метода gather(), где один ожидаемый метод не работает](kak-ispolzovat-asyncio.gather.md#id-4.1.-primer-metoda-gather-gde-odin-ozhidaemyi-metod-ne-rabotaet)
   * [Пример метода gather() с возвращением исключения](kak-ispolzovat-asyncio.gather.md#id-4.2.-primer-metoda-gather-s-vozvrasheniem-isklyucheniya)
   * [Пример метода gather(), в котором одна задача отменена](kak-ispolzovat-asyncio.gather.md#id-4.3.-primer-metoda-gather-v-kotorom-odna-zadacha-otmenena)
   * [Пример метода gather(), где одна задача отменяется с возвратом исключения](kak-ispolzovat-asyncio.gather.md#id-4.4.-primer-metoda-gather-gde-odna-zadacha-otmenyaetsya-s-vozvratom-isklyucheniya)
   * [Пример отмены всех задач в gather()](kak-ispolzovat-asyncio.gather.md#id-4.5.-primer-otmeny-vsekh-zadach-v-gather)
5. [Распространенные ошибки с asyncio.gather()](kak-ispolzovat-asyncio.gather.md#id-5.-rasprostranennye-oshibki-s-asyncio.gather)
   * [Пример ошибки gather() со списком](kak-ispolzovat-asyncio.gather.md#id-5.1.-primer-oshibki-gather-so-spiskom)
   * [Пример ошибки gather() без ожидания await](kak-ispolzovat-asyncio.gather.md#id-5.2.-primer-oshibki-gather-bez-ozhidaniya-await)
6. [Дальнейшее чтение](kak-ispolzovat-asyncio.gather.md#id-6.-dalneishee-chtenie)
7. [Заключение](kak-ispolzovat-asyncio.gather.md#id-7.-zaklyuchenie)



## 1. Что такое Asyncio gather()

[Функция модуля asyncio.gather()](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) позволяет вызывающей стороне группировать несколько ожидаемых объектов вместе.

После группировки ожидаемые объекты могут выполняться одновременно, ожидаться и отменяться.

> Запускайте ожидаемые объекты в последовательности aws одновременно.
>
> _—_ [_Coroutines and Tasks_](https://docs.python.org/3/library/asyncio-task.html)

Это полезная служебная функция как для группировки, так и для выполнения нескольких сопрограмм или нескольких задач.

Например:

```python
...
# запустить коллекцию ожидаемых объектов
results = await asyncio.gather(coro1(), asyncio.create_task(coro2()))
```

Мы можем использовать функцию asyncio.gather() в ситуациях, когда мы можем заранее создать множество задач или сопрограмм, а затем захотеть выполнить их все сразу и дождаться их завершения, прежде чем продолжить.

Это вероятная ситуация, когда результат требуется от многих подобных задач, например. одна и та же задача или сопрограмма с разными данными.

Ожидаемые объекты могут выполняться одновременно, возвращать результаты, а основная программа может возобновить работу, используя результаты, от которых она зависит.

Функция gather() является более мощной, чем просто ожидание завершения задач.

Это позволяет рассматривать группу ожидаемых объектов как один ожидаемый объект.

Это позволяет:

* Выполнение и ожидание выполнения всех ожидаемых объектов в группе с помощью выражения await.
* Получение результатов из всех сгруппированных ожидаемых объектов для последующего получения с помощью метода result().
* Группа ожидаемых объектов, которые будут отменены с помощью метода cancel().
* Проверка того, все ли ожидаемые объекты в группе выполнены с помощью метода done().
* Выполнение функций обратного вызова только тогда, когда все задачи в группе выполнены.

И более.

Функция asyncio.gather() аналогична asyncio.wait(). Она будет приостанавливаться до тех пор, пока все предоставленные задачи не будут выполнены, за исключением того, что он будет возвращать итерацию возвращаемых значений из всех задач, тогда как wait() по умолчанию не будет получать результаты задач.

Вы можете узнать больше о том, чем asyncio.gather() отличается от asyncio.wait(), в этом руководстве:

* [Asyncio gather() vs wait() in Python](https://superfastpython.com/asyncio-gather-vs-wait/)

Теперь, когда мы знаем, что такое функция asyncio.gather(), давайте посмотрим, как мы можем ее использовать.

Запускайте циклы, используя все процессоры. [Загрузите БЕСПЛАТНУЮ книгу](https://superfastpython.com/plip-incontent), чтобы узнать, как это сделать.

## 2. Как использовать Asyncio gather()

В этом разделе мы подробнее рассмотрим, как можно использовать функцию asyncio.gather().

### 2.1. gather() принимает задачи и сопрограммы

Функция asyncio.gather() принимает в качестве аргументов один или несколько ожидаемых объектов.

Напомним, что ожидаемым может быть сопрограмма, объект Future или Task.

Следовательно, мы можем вызвать функцию gather() с помощью:

* Несколько задач
* Несколько сопрограмм
* Смеси задач и сопрограмм

Например:

```python
...
# выполнить несколько сопрограмм
asyncio.gather(coro1(), coro2())
```

Если объекты Task предоставлены для gather(), они уже будут запущены, поскольку задачи Task планируются как часть создания.

Функция asyncio.gather() принимает ожидаемые объекты в качестве аргументов позиции.

Мы не можем создать список или коллекцию ожидаемых объектов и предоставить их для сбора, так как это приведет к ошибке.

Например:

```python
...
# не может предоставить список ожидаемых объектов напрямую
asyncio.gather([coro1(), coro2()])
```

Список ожидаемых объектов можно предоставить, если его сначала распаковать в отдельные выражения с помощью оператора звездочки (\*), также называемого оператором астерикс.

Этот оператор специально распаковывает итерации, например списки, в отдельные выражения. Его часто называют [итеративным оператором распаковки](https://peps.python.org/pep-3132/).

> Звездочка \* обозначает итеративную распаковку. Его операнд должен быть итерируемым. Итерация расширяется до последовательности элементов, которые включаются в новый кортеж, список или набор на месте распаковки.
>
> [_Expression lists_](https://docs.python.org/3/reference/expressions.html)

Например:

```python
...
# gather с распакованным списком ожидаемых объектов
asyncio.gather(*[coro1(), coro2()])
```

Если для метода gather() предусмотрены сопрограммы, они автоматически оборачиваются объектами Task.

### 2.2. gather() возвращает объекты Future

Функция gather() не блокируется.

Вместо этого она возвращает объект asyncio.Future, представляющий группу ожидаемых объектов.

Например:

```python
...
# получить Future, которое представляет собой несколько ожидаемых событий
group = asyncio.gather(coro1(), coro2())
```

После создания объекта Future он автоматически планируется в цикле событий.

Ожидаемый объект представляет группу, и все ожидаемые объекты в группе будут выполнены, как только это будет возможно.

Это означает, что если вызывающий объект больше ничего не сделал, запланированная группа ожидаемых объектов будет запущена (при условии, что вызывающий объект приостанавливается).

Это также означает, что вам не нужно ждать Future, возвращаемого функцией gather().

Например:

```python
...
# получить Future, которое представляет собой несколько ожидаемых событий
group = asyncio.gather(coro1(), coro2())
# приостановите работу и подождите некоторое время, возможно, группа выполняется..
await asyncio.sleep(10)
```

### 2.3. В ожидании объекта Future метода gather()

Возвращенный объект Future может быть ожиданием, которое будет ожидать выполнения всех ожидаемых объектов в группе.

Например:

```python
...
# запустить группу ожидаемых объектов
await group
```

Ожидаемый объект Future, возвращенный из метода gather(), вернет список возвращаемых значений из ожидаемых объектов.

Если ожидаемые объекты не возвращают значение, то этот список будет содержать возвращаемое значение по умолчанию `"None"`.

Например:

```python
...
# запустите группу ожидаемых объектов и получите возвращаемые значения
results = await group
```

Чаще всего это выполняется в одну строку.

Например:

```python
...
# запускайте задачи и получайте результаты в одной строке
results = await asyncio.gather(coro1(), coro2())
```

### 2.4. gather() может вкладывать группы ожидаемых объектов

Функция gather() принимает ожидаемые объекты и сама возвращает ожидаемые объекты.

Таким образом, мы можем создавать вложенные группы ожидаемых объектов.

Например:

```python
...
# создать группу задач
group1 = asyncio.gather(coro1(), coro2())
# создать еще одну группу задач
group2 = asyncio.gather(group1, coro3())
# запустить group2, которая также запустит group1
await group2
```

### 2.5. gather() и исключения

Если ожидаемый объект завершается с ошибкой, исключение повторно возбуждается в вызывающем объекте и, возможно, его необходимо обработать.

Например:

```python
...
try:
	# запускайте задачи и получайте результат
	results = await asyncio.gather(coro1(), coro2())
except Exception as e:
	# ...
```

Аналогичным образом, если задача в группе отменена, она повторно вызовет исключение CancelledError в вызывающей стороне, и, возможно, ее потребуется обработать.

Аргументу return\_exceptions функции gather() можно присвоить значение True, что позволит перехватывать исключения и предоставлять их в качестве возвращаемых значений, а не повторно вызывать их в вызывающей стороне.

Это относится как к исключениям, возникающим в awaitables, так и к исключениям CancelledError, если awaitables отменены.

Например:

```python
...
# запускать задачи и получать результат как  исключение
results = await asyncio.gather(coro1(), coro2(), return_exceptions=True)
```

### 2.6. объект Future метода gather() может быть отменен

Future, возвращаемый функцией gather(), можно использовать так же, как обычный [объект asyncio.Future](https://docs.python.org/3/library/asyncio-future.html#asyncio.Future).

Мы можем проверить, выполнено ли это, вызвав метод done().

Например:

```python
...
# проверить, выполнена ли группа задач
if group.done():
	# ...
```

Мы также можем отменить функцию Future метода gather(), которая отменит все задачи внутри группы.

Например:

```python
...
# отменить все задачи в группе
group.cancel()
```

Другие полезные методы, которые мы могли бы использовать, включают добавление функции обратного вызова done, получение результата и проверку того, была ли группа отменена.

Вы можете узнать больше об использовании обратного вызова Done для задачи сбора в руководстве:

* [Asyncio gather() Добавить функцию обратного вызова Done](https://superfastpython.com/asyncio-gather-done-callback/)

Теперь, когда мы знаем, как использовать asyncio.gather(), давайте рассмотрим несколько реализованных примеров.

## 3. Примеры gather() с сопрограммами

В этом разделе мы рассмотрим, как можно одновременно запускать сопрограммы с помощью функции asyncio.gather().

### 3.1. Пример gather() для одной сопрограммы

Мы можем использовать gather() для управления одной сопрограммой.

Сопрограмму можно выполнить напрямую, создав ее и ожидая ее. Тем не менее, мы можем использовать функцию gather(), чтобы обернуть его в объект Future и создать группу из одного ожидаемого объекта, которым можно управлять.

В приведенном ниже примере определяется сопрограмма задачи, которая собирается и запускается.

```python
# SuperFastPython.com
# пример сбора для одной сопрограммы
import asyncio
 
# сопрограмма, используемая для задачи
async def task_coro():
    # выводит сообщение
    print('task executing')
    # засыпает на время
    await asyncio.sleep(1)
 
# сопрограмма, используемая для точки входа
async def main():
    # выводит сообщение
    print('main starting')
    # создает корутину
    coro = task_coro()
    # ожидает выполнения одной корутины
    await asyncio.gather(coro)
    # выводит сообщение
    print('main done')
 
# старт асинхронной программы
asyncio.run(main())
```

При выполнении примера создается и выполняется сопрограмма main() как точка входа в программу asyncio.

Сопрограмма main() выводит сообщение, а затем создает сопрограмму задачи.

Затем вызывается функция gather(), передавая в качестве аргумента сопрограмму одной задачи. Это возвращает ожидаемый объект Future.

Сопрограмма main() приостанавливается, и сопрограмма задачи выполняется, сообщая сообщение и переходя в режим ожидания перед завершением.

Затем сопрограмма main() возобновляет работу и выдает последнее сообщение.

Это показывает, как мы можем запустить одну сопрограмму с помощью метода gather().

```bash
main starting
task executing
main done
```

### 3.2. Пример gather() для множества сопрограмм

Мы можем использовать gather() для группировки множества сопрограмм в одну задачу.

Это наиболее распространенный вариант использования функции gather().

В приведенном ниже примере определяется сопрограмма задачи, которая принимает аргумент, выводит сообщение с аргументом и на мгновение переходит в режим ожидания.

Затем основная сопрограмма вызывает gather() с тремя отдельными вызовами сопрограммы задачи, каждый с разными аргументами. Это позволяет всем трем сопрограммам выполняться одновременно, а вызывающая сторона ожидает завершения всех трех сопрограмм перед возобновлением.

Полный пример приведен ниже.

```python
# SuperFastPython.com
# пример gather для многих сопрограмм
import asyncio
 
# сопрограмма, используемая для задачи
async def task_coro(value):
    # выводит сообщение
    print(f'>task {value} executing')
    # засыпает на время
    await asyncio.sleep(1)
 
# сопрограмма, используемая для точки входа
async def main():
    # выводит сообщение
    print('main starting')
    # запускает задачи
    await asyncio.gather(task_coro(0),
        task_coro(1),
        task_coro(2))
    # выводит сообщение
    print('main done')
 
# старт асинхронной программы
asyncio.run(main())
```

При выполнении примера выполняется сопрограмма main() как точка входа в программу.

Выводится сообщение, а затем вызывается функция gather(). Ему передаются три разных экземпляра сопрограммы, которые вызывают одну и ту же функцию сопрограммы с разными аргументами.

Сопрограммы запускаются одновременно, а основная coroutine() приостанавливается и ожидает выполнения группы ожидаемых объектов.

Каждая сопрограмма запускается, выводит свое сообщение, на мгновение приостанавливается и завершает работу.

Сопрограмма main() возобновляет работу только после завершения всех трех сопрограмм, а затем сообщает свое последнее сообщение.

Это подчеркивает наиболее распространенный вариант использования нескольких сопрограмм и ожидания их завершения.

```bash
main starting
>task 0 executing
>task 1 executing
>task 2 executing
main done
```

### 3.3. Пример gather() для множества сопрограмм в списке

Обычно заранее создают несколько сопрограмм, а затем собирают их позже.

Это позволяет программе подготовить задачи, которые должны выполняться одновременно, а затем запустить их одновременное выполнение и дождаться их завершения.

Мы можем собрать множество сопрограмм в список либо вручную, либо с помощью выражения списка.

Например:

```python
...
# создать множество сопрограмм
coros = [task_coro(i) for i in range(10)]
```

Затем мы можем вызвать gather() со всеми сопрограммами в списке.

Список сопрограмм не может быть передан непосредственно в функцию gather(), так как это приведет к ошибке.

Вместо этого функция gather() требует, чтобы каждый ожидаемый объект был предоставлен в виде отдельного позиционного аргумента.

Этого можно добиться, развернув список на отдельные выражения и передав их в функцию gather(). За нас эту операцию выполнит оператор звездочки (\*).

Например:

```python
...
# запуск задач
await asyncio.gather(*coros)
```

Вы новичок в использовании оператора звездочки или астерикса (\*)? Она используется для [итеративной распаковки](https://peps.python.org/pep-3132/). Дополнительную информацию можно найти в [документации по API выражений](https://docs.python.org/3/reference/expressions.html#expression-lists).

Ниже приведен полный пример запуска списка заранее подготовленных сопрограмм с помощью метода gather().

```python
# SuperFastPython.com
# пример сбора множества сопрограмм в списке
import asyncio
 
# сопрограмма, используемая для задачи
async def task_coro(value):
    # выводит сообщение
    print(f'>task {value} executing')
    # засыпает на время
    await asyncio.sleep(1)
 
# сопрограмма, используемая для точки входа
async def main():
    # выводит сообщение
    print('main starting')
    # создание множества сопрограмм
    coros = [task_coro(i) for i in range(10)]
    # запуск задач
    await asyncio.gather(*coros)
    # выводит сообщение
    print('main done')
 
# старт асинхронной задачи
asyncio.run(main())
```

При выполнении примера выполняется сопрограмма main() как точка входа в программу.

Затем сопрограмма main() создает список из 10 объектов сопрограммы, используя выражение списка.

Затем этот список передается функции gather() и распаковывается в 10 отдельных выражений с помощью оператора звезды.

Затем сопрограмма main() ожидает объекта Future, возвращенного из вызова метода gather(), приостанавливая и ожидая завершения выполнения всех запланированных сопрограмм.

Сопрограммы запускаются, как только могут, сообщая свои уникальные сообщения и переходя в режим ожидания перед завершением.

Только после того, как все сопрограммы в группе завершены, сопрограмма main() возобновляет работу и сообщает свое последнее сообщение.

Это показывает, как мы можем подготовить коллекцию сопрограмм и предоставить их в виде отдельных выражений для функции gather().

```bash
main starting
>task 0 executing
>task 1 executing
>task 2 executing
>task 3 executing
>task 4 executing
>task 5 executing
>task 6 executing
>task 7 executing
>task 8 executing
>task 9 executing
main done
```

### 3.4. Пример метода gather() с возвращаемыми значениями

Мы можем выполнять сопрограммы, которые возвращают значение.

Использование функции gather() для выполнения нескольких сопрограмм, возвращающих значения, позволяет собирать результаты всех сопрограмм в одной точке для использования, давая функции gather() свое имя.

Напомним, что функция gather() не блокирует, а немедленно возвращает объект Future.

Когда ожидается объект Future, возвращаемый функцией gather(), он возвращает список возвращаемых значений из сгруппированных задач.

В приведенном ниже примере это демонстрируется путем обновления сопрограммы задачи для возврата значения, а также сбора и составления отчета о списке возвращаемых значений из всех задач в основной сопрограмме.

```python
# SuperFastPython.com
# пример gather для множества сопрограмм, возвращающих значения
import asyncio
 
# сопрограмма, используемая для задачи
async def task_coro(value):
    # выводит сообщение
    print(f'>task {value} executing')
    # засыпает на время
    await asyncio.sleep(1)
    # возвращает значение
    return value * 10
 
# сопрограмма, используемая для точки входа
async def main():
    # выводит сообщение
    print('main starting')
    # создание множества задач
    tasks = [task_coro(i) for i in range(10)]
    # запуск задач
    values = await asyncio.gather(*tasks)
    # выводит значения
    print(values)
    # выводит сообщение
    print('main done')
 
# старт асинхронной задачи
asyncio.run(main())
```

При выполнении примера сначала создается и запускается сопрограмма main() в качестве точки входа в программу.

Затем создается список сопрограмм, каждая со своим аргументом.

Вызывается функция gather, а затем список сопрограмм распаковывается в отдельные выражения с помощью оператора звезды.

Это планирует выполнение каждой сопрограммы.

Основная сопрограмма приостанавливает работу и ожидает завершения всех сопрограмм в группе.

Каждая сопрограмма запускается, сообщает сообщение, переходит в режим сна и возвращает значение, кратное 10 входному аргументу.

Все сопрограммы завершены, и ожидаемое значение Future, возвращаемое функцией gather(), предоставляет список возвращаемых значений.

Затем сопрограмма main() сообщает список возвращаемых значений.

Это показывает, как мы можем получать возвращаемые значения из нескольких сопрограмм, которые возвращают значения.

```bash
main starting
>task 0 executing
>task 1 executing
>task 2 executing
>task 3 executing
>task 4 executing
>task 5 executing
>task 6 executing
>task 7 executing
>task 8 executing
>task 9 executing
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
main done
```

### 3.5. Пример gather() с вложенными группами

Функцию gather() можно использовать для создания одного ожидаемого объекта, представляющего несколько ожидаемых объектов.

Естественным следствием этого является то, что мы можем вкладывать группы ожидаемых объектов.

Мы можем продемонстрировать это на рабочем примере.

В этом примере мы создаем две отдельные группы по три сопрограммы. Затем мы определяем третью группу, которая объединяет две ранее созданные группы сопрограмм.

Это создает иерархию с тремя уровнями ожидаемых объектов, например:

#### group 3

* group 1
  * coroutine 0
  * coroutine 1
  * coroutine 2
* group 2
  * coroutine 3
  * coroutine 4
  * coroutine 5

Выполнение операции над ожидаемым объектом верхнего уровня приведет к выполнению операции со всеми вложенными ожидаемыми объектами.

Самое главное, что при запуске верхнего уровня все вложенные ожидаемые объекты будут выполняться одновременно.

Полный пример приведен ниже.

```renpy
# SuperFastPython.com
# пример gather и вложенных групп сопрограмм
import asyncio
 
# сопрограмма, используемая для задачи
async def task_coro(value):
    # выводит сообщение
    print(f'>task {value} executing')
    # засыпает на время
    await asyncio.sleep(1)
 
# сопрограмма, используемая для точки входа
async def main():
    # выводит сообщение
    print('main starting')
    # создает группу уровня 1
    group1 = asyncio.gather(task_coro(0), task_coro(1), task_coro(2))
    # создает группу уровня 2
    group2 = asyncio.gather(task_coro(3), task_coro(4), task_coro(5))
    # создает группу уровня 3
    group3 = asyncio.gather(group1, group2)
    # выполнить 3, который выполняет 1 и 2
    await group3
    # выводит сообщение
    print('main done')
 
# старт асинхронной задачи
asyncio.run(main())
```

При выполнении примера сначала создается и запускается сопрограмма main().

Сопрограмма main() сначала использует функцию gather() для создания двух отдельных групп сопрограмм. Затем он вызывает метод gather(), чтобы создать третью группу, которая объединяет первые две группы сопрограмм.

Затем он ожидает третью группу.

Это планирует выполнение всех ожидаемых объектов и приостанавливает основную сопрограмму до тех пор, пока иерархия ожидаемых объектов не будет завершена.

Все ожидаемые операции завершены, и основная сопрограмма возобновляет работу и выдает последнее сообщение.

Это показывает, как мы можем легко создавать иерархии групп ожидаемых объектов с помощью функции gather().

```bash
main starting
>task 0 executing
>task 1 executing
>task 2 executing
>task 3 executing
>task 4 executing
>task 5 executing
main done
```

### 3.6. Пример сочетания задач и сопрограмм с помощью метода gather()

## 4. Примеры gather() с ошибками

### 4.1. Пример метода gather(), где один ожидаемый метод не работает

### 4.2. Пример метода gather() с возвращением исключения

### 4.3. Пример метода gather(), в котором одна задача отменена

### 4.4. Пример метода gather(), где одна задача отменяется с возвратом исключения

### 4.5. Пример отмены всех задач в gather()

## 5. Распространенные ошибки с asyncio.gather()

### 5.1. Пример ошибки gather() со списком

### 5.2. Пример ошибки gather() без ожидания await

## 6. Дальнейшее чтение

## 7. Заключение
