# Асинхронные запросы в Python

{% hint style="info" %}
Ссылка на оригинальную статью: [Asynchronous Requests in Python](https://superfastpython.com/python-async-requests/)

Опубликовано: 12 декабря 2023

Авторы:  [Jason Brownlee](https://superfastpython.com/about)
{% endhint %}

Мы можем выполнять асинхронные запросы в Python.

Библиотека Requests Python не поддерживает asyncio напрямую.

Если мы сделаем HTTP-запросы с использованием библиотеки Requests, это заблокирует цикл событий asyncio и предотвратит выполнение всех других сопрограмм в программе.

Вместо этого мы можем выполнять асинхронные запросы, используя метод asyncio.to\_thread(), предоставленный в модуле asyncio стандартной библиотеки Python. Это запустит блокирующий сетевой вызов ввода-вывода в отдельном рабочем потоке, имитируя асинхронный или неблокирующий вызов функции ввода-вывода.

В этом руководстве вы узнаете, как безопасно использовать библиотеку Requests для HTTP-запросов в асинхронных программах.

Давайте начнем.

## Содержание

1. Requests блокируют цикл событий Asyncio (это плохо)
2. Как использовать requests в Asyncio
3. Пример API requests (обычный Python)
4. Пример API requests в Asyncio (блокировка цикла событий)
5. Пример подтверждения запросов API, блокирующих цикл событий Asyncio
6. Пример выполнения вызовов API запросов в отдельном потоке
7. Дальнейшее чтение
8. Вынос

## Requests блокирует цикл событий Asyncio (это плохо)

HTTP-клиенты составляют большую часть разработки Python.

Большинство API, которые мы используем для доступа к удаленным ресурсам, веб-сайтам и SaaS, будут скрытно использовать HTTP-запросы, обычно через интерфейс RESTful.

HTTP-запросы — это тип сетевого ввода-вывода, и мы можем захотеть разработать асинхронную программу, которая использует API, чтобы у нас было много сотен или тысяч одновременных клиентских HTTP-соединений.

Самая популярная библиотека Python для выполнения HTTP-запросов — это библиотека Requests.

[Requests](https://github.com/psf/requests): простая, но элегантная HTTP-библиотека.

> Requests позволяет очень легко отправлять запросы HTTP/1.1. Нет необходимости вручную добавлять строки запроса к вашим URL-адресам или кодировать данные PUT и POST с помощью формы — но в настоящее время просто используйте метод json!
>
> _—_ [_Requests GitHub Project_](https://github.com/psf/requests)_._

Проблема в том, что библиотеку Requests нельзя использовать напрямую в [асинхронных программах](https://superfastpython.com/python-asyncio/).

Причина в том, что библиотека Requests блокирует цикл событий asyncio при открытии, записи и чтении из соединения HTTP-сокета.

Это означает, что вся программа asyncio будет приостановлена до тех пор, пока HTTP-запрос не будет завершен.

Это плохо, потому что вся идея внедрения asyncio заключается в использовании асинхронного программирования для одновременного выполнения множества задач и выполнения неблокирующего сетевого ввода-вывода.

_**Как мы можем безопасно использовать запросы в асинхронных программах?**_

Выполняйте циклы, используя все процессоры. [Загрузите БЕСПЛАТНУЮ книгу](https://superfastpython.com/plip-incontent), чтобы узнать, как это сделать.

## Как использовать requests в Asyncio

Мы можем использовать библиотеку Requests для безопасного выполнения HTTP-запросов в асинхронных программах, запустив блокирующий вызов в новом потоке.

Этого можно добиться с помощью функции модуля [asyncio.to\_thread()](https://superfastpython.com/asyncio-to\_thread/).

asyncio.to\_thread() будет использовать ThreadPoolExecutor за кулисами для выполнения вызова в новом потоке одновременно с программой asyncio.

Нам нужно запустить блокирующий сетевой запрос в новом потоке, поскольку asyncio запускает все сопрограммы в одном потоке. Если одна сопрограмма в программе asyncio блокирует текущий поток, она блокирует все сопрограммы в потоке.

Выполняя блокирующий вызов в отдельном потоке, он позволяет циклу событий продолжать работу и выполнять все другие сопрограммы, работающие в программе.

Функцию модуля asyncio.to\_thread() можно рассматривать как неблокирующий вызов, что позволяет нам моделировать асинхронные запросы или неблокирующий сетевой ввод-вывод с помощью библиотеки requests.

Типичный HTTP-запрос GET, выполняемый с помощью библиотеки requests, выполняется с помощью функции `requests.get()`.

Например:

```python
...
# perform http get
result = requests.get('https://python.org/')
```

Это заблокирует цикл событий.

Мы можем сделать этот вызов в новом потоке, ожидая вызова asyncio.to\_thread().

Например:

```python
...
# perform http get
result = await asyncio.to_thread(requests.get, 'https://python.org/')
```

Обратите внимание, что asyncio.to\_thread() принимает имя метода или функции для вызова и каждый аргумент, который необходимо предоставить целевой функции.

Вы можете узнать больше о функции asyncio.to\_thread() в руководстве:

* [Как использовать Asyncio to\_thread()](https://superfastpython.com/asyncio-to\_thread/)

Вы можете узнать больше об обработке задач блокировки в асинхронных программах в руководстве:

* [Как запускать задачи блокировки в Asyncio](https://superfastpython.com/asyncio-blocking-tasks/)

Другим решением было бы использовать альтернативу библиотеке Requests, которая напрямую поддерживает asyncio, например, клиентская библиотека HTTP с асинхронной поддержкой. Популярные примеры включают [aiohttp](https://github.com/aio-libs/aiohttp) и [httpx](https://github.com/encode/httpx/).

Теперь, когда мы знаем, как безопасно использовать библиотеку Requests в asyncio, давайте посмотрим на некоторые рабочие примеры.

[Загрузите сейчас: бесплатную шпаргалку по Asyncio в формате PDF](https://marvelous-writer-6152.ck.page/d29b7d8dfb)

## Пример API запросов requests (обычный Python)

Во-первых, давайте посмотрим, как создать простой HTTP-запрос GET с использованием библиотеки Requests.

В приведенном ниже примере выполняется запрос и сообщается статус HTTP и длина контента.

```python
# SuperFastPython.com
# пример http-клиента с запросами
import requests
# определите URL-адрес, который мы хотим получить
url = 'https://python.org/'
# выполнить HTTP GET
result = requests.get(url)
# сообщить о результатах
print(f'Status Code: {result.status_code}')
print(f'Content Length: {len(result.text)}')
```

Запуск программы выполняет запрос и сообщает код состояния и длину всего загруженного текста.

Мы видим, что это очень чистый и простой API.

HTTP GET — это блокирующий вызов, который открывает сетевое соединение, отправляет HTTP-запрос и загружает HTTP-ответ, а затем анализирует ответ на структуры, к которым мы можем получить доступ.

```bash
Status Code: 200
Content Length: 51225
```
