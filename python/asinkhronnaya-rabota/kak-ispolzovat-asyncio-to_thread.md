# Как использовать asyncio to\_thread()

{% hint style="info" %}
Ссылка на оригинальную статью: [How to Use Asyncio to\_thread()](https://superfastpython.com/asyncio-to\_thread/)

Опубликовано: 29 ноября 2022

Авторы:  [Jason Brownlee](https://superfastpython.com/about)
{% endhint %}

Вы можете запустить блокирующую функцию в asyncio с помощью функции asyncio.to\_thread().

В этом руководстве вы узнаете, как выполнять функции блокировки в новых потоках отдельно от цикла событий asyncio.

Давайте начнем.

## Оглавление

1. Проблема с блокировкой цикла событий
2. Запустить функцию в новом потоке с помощью to\_thread()
3. Как использовать to\_thread()
4. Пример блокировки цикла событий Asyncio
5. Запуск функции блокировки в новом потоке
   1. Какая разница?
6. Запуск функции блокировки с аргументами в новом потоке
7. Запуск функции блокировки с возвращаемым значением в новом потоке
8. Независимое выполнение функции блокировки в новом потоке
9. Пример отчета о деталях новой темы
10. Дальнейшее чтение
11. Заключение

## Проблема с блокировкой цикла событий

Проблема с asyncio заключается в том, что если в цикле событий выполняется блокирующий вызов, это останавливает приложение.

Это связано с тем, что одновременно может выполняться только одна сопрограмма.

Напомним, что блокирующий вызов — это вызов функции, который не возвращает результат до завершения.

Вместо того, чтобы просто приостанавливать текущую сопрограмму, вызов приостановит поток, в котором выполняется сопрограмма.

Примеры включают блокировку ввода-вывода, например чтение или запись из файла, или спящий режим, например вызов `time.sleep()`.

Подробнее о блокировке вызовов функций вы можете узнать из статьи:

* [Вызов блокировки потока в Python](https://superfastpython.com/thread-blocking-call-in-python/)

Как мы можем выполнить вызов поток с блокирующей функцией в asyncio?

Выполняйте циклы, используя все процессоры. [Загрузите БЕСПЛАТНУЮ книгу](https://superfastpython.com/plip-incontent), чтобы узнать, как это сделать.

## Запуск функции в новом потоке с помощью to\_thread()

Мы можем выполнять вызовы блокирующих функций в потоке в asyncio, используя функцию [asyncio.to\_thread()](https://docs.python.org/3/library/asyncio-task.html#asyncio.to\_thread).

> Асинхронно запускает функцию func в отдельном потоке.
>
> _—_ [_Coroutines and Tasks_](https://docs.python.org/3/library/asyncio-task.html)

Эта функция была добавлена в модуль asyncio в **Python 3.9**.

Он примет вызов функции и выполнит ее в новом потоке, отдельном от потока, выполняющего цикл событий asyncio.

Это позволяет циклу событий asyncio обрабатывать вызовы блокирующей функции как сопрограмму и выполнять асинхронно, используя параллелизм на основе потоков вместо параллелизма на основе сопрограммы.

Функция `asyncio.to_thread()` специально разработана для выполнения блокирующих функций ввода-вывода, а не функций, связанных с ЦП, которые также могут блокировать цикл событий asyncio.

> Эта функция сопрограммы в первую очередь предназначена для выполнения функций/методов, связанных с вводом-выводом, которые в противном случае заблокировали бы цикл событий, если бы они выполнялись в основном потоке.
>
> _—_ [_Coroutines and Tasks_](https://docs.python.org/3/library/asyncio-task.html)

Это полезная функция, которую можно использовать, когда у нас есть асинхронная программа, которой необходимо выполнять как неблокирующий ввод-вывод (например, с сокетами), так и блокирующий ввод-вывод (например, с файлами).

Теперь, когда мы знаем, как асинхронно выполнять функции блокировки в asyncio, давайте посмотрим, как использовать функцию `to_thread()`.

[Загрузите сейчас: бесплатную шпаргалку по Asyncio в формате PDF](https://marvelous-writer-6152.ck.page/d29b7d8dfb)

## Как использовать to\_thread()

Функция `to_thread()` принимает имя блокирующей функции для выполнения и любые аргументы этой функции.

Затем он возвращает сопрограмму, которую можно ожидать, чтобы получить возвращаемое значение от функции, если таковое имеется.

Например:

```python
...
# создать сопрограмму для блокирующей функции
blocking_coro = asyncio.to_thread(blocking, arg1, arg2)
# дождитесь сопрограммы и получите возвращаемое значение
result = await blocking_coro
```

Функция блокировки не будет выполняться в новом потоке до тех пор, пока она не будет ожидаема или выполнена неприлично.

Сопрограмму можно обернуть в asyncio.Task для независимого выполнения вызова блокирующей функции.

Например:

```python
...
# создать сопрограмму для блокирующей функции
blocking_coro = asyncio.to_thread(blocking)
# выполнить функцию блокировки самостоятельно
task = asyncio.create_task(blocking_coro)
```

Это позволяет использовать вызов блокирующую функцию как любую другую асинхронную задачу.

Теперь, когда мы знаем, как использовать функцию `asyncio.to_thread()`, давайте посмотрим на некоторые рабочие примеры.

## Пример блокировки цикла событий Asyncio

Прежде чем мы рассмотрим пример запуска блокирующей функции в новом потоке, давайте рассмотрим пример запуска блокирующей функции непосредственно в цикле событий asyncio.

В этом примере мы определим вызов блокирующей функции, которая выводит сообщение, переходит в режим сна, а затем выводит окончательное сообщение. Важно отметить, что [функция time.sleep()](https://docs.python.org/3/library/time.html#time.sleep) используется для блокировки текущего потока, включая любые выполняемые в данный момент сопрограммы.

Вы можете узнать больше о блокировке потока с помощью сна в руководстве:

* [Как остановить поток в Python](https://superfastpython.com/thread-sleep-in-python/)

Мы также определяем фоновую сопрограмму, которая работает в цикле вечно. На каждой итерации он сообщает сообщение и засыпает на полсекунды.

Основная сопрограмма самостоятельно запускает фоновую задачу. Затем он вызывает блокирующую функцию.

Полный пример приведен ниже.

```python
# SuperFastPython.com
# пример запуска вызова блокирующей функции в asyncio
import time
import asyncio
 
# блокирующая функция
def blocking_task():
    # выводит сообщение
    print('task is running')
    # блокировка
    time.sleep(2)
    # выводит сообщение
    print('task is done')
 
# фоновая задача сопрограммы
async def background():
    # вечное кольцо
    while True:
        # выводит сообщение
        print('>background task running')
        # засыпает на некоторое время
        await asyncio.sleep(0.5)
 
# основная корутина
async def main():
    # запустить фоновую задачу
    _= asyncio.create_task(background())
    # выполнить блокирующий вызов
    blocking_task()
 
# запустить программу asyncio
asyncio.run(main())
```

При выполнении примера сначала создается сопрограмма `main()` и используется она как вход в программу asyncio.

Сопрограмма `main()` запускается. Она создает фоновую сопрограмму и планирует ее выполнение как можно скорее.

Затем сопрограмма `main()` вызывает функцию `blocking_task()`.

Это не приостанавливает сопрограмму `main()`, вместо этого вызов функции `blocking_task()` выполняется в цикле событий, а вызов `sleep()` блокирует текущий поток.

Сопрограмма фоновой задачи не может быть запущена.

После завершения вызова блокировки фоновой задаче предоставляется возможность ненадолго запуститься перед завершением сопрограммы `main()`.

Это подчеркивает, что вызов функции блокировки в сопрограмме или задаче не приостанавливается и блокирует весь цикл событий.

```bash
task is running
task is done
>background task running
```

Далее давайте посмотрим, как мы можем обновить пример, чтобы запустить блокирующий вызов в новом потоке.

Перегружены API-интерфейсами параллелизма Python? Найдите облегчение, загрузите мои [БЕСПЛАТНЫЕ ментальные карты Python Concurrency](https://marvelous-writer-6152.ck.page/8f23adb076)
