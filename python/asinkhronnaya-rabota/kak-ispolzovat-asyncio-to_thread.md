# Как использовать asyncio to\_thread()

{% hint style="info" %}
Ссылка на оригинальную статью: [How to Use Asyncio to\_thread()](https://superfastpython.com/asyncio-to\_thread/)

Опубликовано: 29 ноября 2022

Авторы:  [Jason Brownlee](https://superfastpython.com/about)
{% endhint %}

Вы можете запустить блокирующую функцию в asyncio с помощью функции asyncio.to\_thread().

В этом руководстве вы узнаете, как выполнять функции блокировки в новых потоках отдельно от цикла событий asyncio.

Давайте начнем.

## Оглавление

1. Проблема с блокировкой цикла событий
2. Запустить функцию в новом потоке с помощью to\_thread()
3. Как использовать to\_thread()
4. Пример блокировки цикла событий Asyncio
5. Запуск функции блокировки в новом потоке
   1. Какая разница?
6. Запуск функции блокировки с аргументами в новом потоке
7. Запуск функции блокировки с возвращаемым значением в новом потоке
8. Независимое выполнение функции блокировки в новом потоке
9. Пример отчета о деталях новой темы
10. Дальнейшее чтение
11. Заключение

## Проблема с блокировкой цикла событий

Проблема с asyncio заключается в том, что если в цикле событий выполняется блокирующий вызов, это останавливает приложение.

Это связано с тем, что одновременно может выполняться только одна сопрограмма.

Напомним, что блокирующий вызов — это вызов функции, который не возвращает результат до завершения.

Вместо того, чтобы просто приостанавливать текущую сопрограмму, вызов приостановит поток, в котором выполняется сопрограмма.

Примеры включают блокировку ввода-вывода, например чтение или запись из файла, или спящий режим, например вызов `time.sleep()`.

Подробнее о блокировке вызовов функций вы можете узнать из статьи:

* [Вызов блокировки потока в Python](https://superfastpython.com/thread-blocking-call-in-python/)

Как мы можем выполнить вызов поток с блокирующей функцией в asyncio?

Выполняйте циклы, используя все процессоры. [Загрузите БЕСПЛАТНУЮ книгу](https://superfastpython.com/plip-incontent), чтобы узнать, как это сделать.

## Запуск функции в новом потоке с помощью to\_thread()

Мы можем выполнять вызовы блокирующих функций в потоке в asyncio, используя функцию [asyncio.to\_thread()](https://docs.python.org/3/library/asyncio-task.html#asyncio.to\_thread).

> Асинхронно запускает функцию func в отдельном потоке.
>
> _—_ [_Coroutines and Tasks_](https://docs.python.org/3/library/asyncio-task.html)

Эта функция была добавлена в модуль asyncio в **Python 3.9**.

Он примет вызов функции и выполнит ее в новом потоке, отдельном от потока, выполняющего цикл событий asyncio.

Это позволяет циклу событий asyncio обрабатывать вызовы блокирующей функции как сопрограмму и выполнять асинхронно, используя параллелизм на основе потоков вместо параллелизма на основе сопрограммы.

Функция `asyncio.to_thread()` специально разработана для выполнения блокирующих функций ввода-вывода, а не функций, связанных с ЦП, которые также могут блокировать цикл событий asyncio.

> Эта функция сопрограммы в первую очередь предназначена для выполнения функций/методов, связанных с вводом-выводом, которые в противном случае заблокировали бы цикл событий, если бы они выполнялись в основном потоке.
>
> _—_ [_Coroutines and Tasks_](https://docs.python.org/3/library/asyncio-task.html)

Это полезная функция, которую можно использовать, когда у нас есть асинхронная программа, которой необходимо выполнять как неблокирующий ввод-вывод (например, с сокетами), так и блокирующий ввод-вывод (например, с файлами).

Теперь, когда мы знаем, как асинхронно выполнять функции блокировки в asyncio, давайте посмотрим, как использовать функцию `to_thread()`.

[Загрузите сейчас: бесплатную шпаргалку по Asyncio в формате PDF](https://marvelous-writer-6152.ck.page/d29b7d8dfb)

## Как использовать to\_thread()

Функция `to_thread()` принимает имя блокирующей функции для выполнения и любые аргументы этой функции.

Затем он возвращает сопрограмму, которую можно ожидать, чтобы получить возвращаемое значение от функции, если таковое имеется.

Например:

```python
...
# создать сопрограмму для блокирующей функции
blocking_coro = asyncio.to_thread(blocking, arg1, arg2)
# дождитесь сопрограммы и получите возвращаемое значение
result = await blocking_coro
```

Функция блокировки не будет выполняться в новом потоке до тех пор, пока она не будет ожидаема или выполнена неприлично.

Сопрограмму можно обернуть в asyncio.Task для независимого выполнения вызова блокирующей функции.

Например:

```python
...
# создать сопрограмму для блокирующей функции
blocking_coro = asyncio.to_thread(blocking)
# выполнить функцию блокировки самостоятельно
task = asyncio.create_task(blocking_coro)
```

Это позволяет использовать вызов блокирующую функцию как любую другую асинхронную задачу.

Теперь, когда мы знаем, как использовать функцию `asyncio.to_thread()`, давайте посмотрим на некоторые рабочие примеры.

## Пример блокировки цикла событий Asyncio

Прежде чем мы рассмотрим пример запуска блокирующей функции в новом потоке, давайте рассмотрим пример запуска блокирующей функции непосредственно в цикле событий asyncio.

В этом примере мы определим вызов блокирующей функции, которая выводит сообщение, переходит в режим сна, а затем выводит окончательное сообщение. Важно отметить, что [функция time.sleep()](https://docs.python.org/3/library/time.html#time.sleep) используется для блокировки текущего потока, включая любые выполняемые в данный момент сопрограммы.

Вы можете узнать больше о блокировке потока с помощью сна в руководстве:

* [Как остановить поток в Python](https://superfastpython.com/thread-sleep-in-python/)

Мы также определяем фоновую сопрограмму, которая работает в цикле вечно. На каждой итерации он сообщает сообщение и засыпает на полсекунды.

Основная сопрограмма самостоятельно запускает фоновую задачу. Затем он вызывает блокирующую функцию.

Полный пример приведен ниже.

```python
# SuperFastPython.com
# пример запуска вызова блокирующей функции в asyncio
import time
import asyncio
 
# блокирующая функция
def blocking_task():
    # выводит сообщение
    print('task is running')
    # блокировка
    time.sleep(2)
    # выводит сообщение
    print('task is done')
 
# фоновая задача сопрограммы
async def background():
    # вечное кольцо
    while True:
        # выводит сообщение
        print('>background task running')
        # засыпает на некоторое время
        await asyncio.sleep(0.5)
 
# основная корутина
async def main():
    # запустить фоновую задачу
    _= asyncio.create_task(background())
    # выполнить блокирующий вызов
    blocking_task()
 
# запустить программу asyncio
asyncio.run(main())
```

При выполнении примера сначала создается сопрограмма `main()` и используется она как вход в программу asyncio.

Сопрограмма `main()` запускается. Она создает фоновую сопрограмму и планирует ее выполнение как можно скорее.

Затем сопрограмма `main()` вызывает функцию `blocking_task()`.

Это не приостанавливает сопрограмму `main()`, вместо этого вызов функции `blocking_task()` выполняется в цикле событий, а вызов `sleep()` блокирует текущий поток.

Сопрограмма фоновой задачи не может быть запущена.

После завершения вызова блокировки фоновой задаче предоставляется возможность ненадолго запуститься перед завершением сопрограммы `main()`.

Это подчеркивает, что вызов функции блокировки в сопрограмме или задаче не приостанавливается и блокирует весь цикл событий.

```bash
task is running
task is done
>background task running
```

Далее давайте посмотрим, как мы можем обновить пример, чтобы запустить блокирующий вызов в новом потоке.

Перегружены API-интерфейсами параллелизма Python? Найдите облегчение, загрузите мои [БЕСПЛАТНЫЕ ментальные карты Python Concurrency](https://marvelous-writer-6152.ck.page/8f23adb076)

## Запуск блокирующей функции в новом потоке

Мы можем изучить, как выполнить блокирующий вызов в новом потоке и не останавливать цикл обработки событий.

В приведенном ниже примере мы вызываем `asyncio.to_thread()`, чтобы создать сопрограмму для вызова функции `blocking_task()`.

Затем ожидается эта сопрограмма, позволяющая приостановить основную сопрограмму и выполнить блокирующую функцию в новом потоке.

Полный пример приведен ниже.

```python
# SuperFastPython.com
# пример запуска вызова блокирующей функции в asyncio в новом потоке
import time
import asyncio
 
# блокирующая функция
def blocking_task():
    # вывод сообщения
    print('task is running')
    # блокирование
    time.sleep(2)
    # вывод сообщения
    print('task is done')
 
# фоновая задача сопрограммы
async def background():
    # вечный цикл
    while True:
        # вывод сообщения
        print('>background task running')
        # засыпает на некоторое время
        await asyncio.sleep(0.5)
 
# основная корутина
async def main():
    # запустить фоновую задачу
    _= asyncio.create_task(background())
    # создать сопрограмму для вызова блокирующей функции
    coro = asyncio.to_thread(blocking_task)
    # выполнить вызов в новом потоке и дождаться результата
    await coro
 
# запустить программу asyncio
asyncio.run(main())
```

При выполнении примера сначала создается сопрограмма `main()` и используется она как вход в программу asyncio.

Сопрограмма `main()` запускается. Он создает фоновую сопрограмму и планирует ее выполнение как можно скорее.

Затем сопрограмма `main()` создает сопрограмму для запуска фоновой задачи в новом потоке, а затем ожидает эту сопрограмму.

Это делает несколько вещей.

Во-первых, он приостанавливает сопрограмму `main()`, позволяя запускаться любым другим сопрограммам в цикле событий, например новой сопрограмме для выполнения блокирующей функции в новом потоке.

Новая сопрограмма запускается, запускает новый поток и выполняет блокирующую функцию в новом потоке. Эта сопрограмма также была приостановлена.

Цикл событий является бесплатным, и фоновая сопрограмма получает возможность запускаться, зацикливаться и выводить свои сообщения.

Блокирующий вызов в другом потоке завершается, фоновая задача приостанавливается, возобновляется основной поток и завершается программа.

Это подчеркивает, что запуск блокирующего вызова в новом потоке не блокирует цикл событий, позволяя запускать другие сопрограммы во время выполнения блокирующего вызова, приостанавливая какой-либо поток, отличный от основного потока цикла событий.

```bash
task is running
>background task running
>background task running
>background task running
>background task running
task is done
```

### Какая разница?

Давайте остановимся на мгновение и рассмотрим разницу между этим примером и предыдущим примером.

В обоих случаях сопрограмма `main()` ожидает завершения блокирующего вызова.

* В первом случае блокирующий вызов приостановил весь поток.
* Во втором случае блокирующий вызов выполняется в новом потоке и приостанавливается только сопрограмма.

Первый случай предотвращает запуск любых других сопрограмм, пока блокирующий вызов заблокирован и ожидает. Второй случай позволяет запускать другие сопрограммы, пока блокирующий вызов заблокирован и ожидает, как видно из выходных данных программы.

Теперь у нас есть хорошее представление о том, что делает функция `to_thread()`, и теперь мы можем рассмотреть другие детали при использовании этой функции.

Далее давайте посмотрим на выполнение блокирующего вызова, который принимает аргументы в новом потоке.

## Запуск блокирующей функции с аргументами в новом потоке

Мы можем изучить, как выполнить блокирующий вызов в новом потоке, принимающем аргументы.

В этом примере мы обновим функцию блокировки, чтобы она принимала два аргумента. Эти аргументы передаются в `asyncio.to_thread()` напрямую, а не в кортеже или словаре.

Блокирующая функция будет выполнена в новом потоке и сообщит аргументы.

Полный пример приведен ниже.

```python
# SuperFastPython.com
# пример запуска вызова блокирующей функции в asyncio в новом потоке с аргументами
import time
import asyncio
 
# блокирующая функция
def blocking_task(value1, value2):
    # вывод сообщения
    print(f'task is running with {value1} and {value2}')
    # блокировка
    time.sleep(2)
    # вывод сообщения
    print('task is done')
 
# основная корутина
async def main():
    # создать сопрограмму для вызова блокирующей функции
    coro = asyncio.to_thread(blocking_task, 100, 'TEST')
    # выполнить вызов в новом потоке и дождаться результата
    await coro
 
# запустить программу asyncio
asyncio.run(main())
```

При выполнении примера сначала создается сопрограмма `main()` и используется она как вход в программу asyncio.

Сопрограмма `main()` запускается и создает сопрограмму для запуска фоновой задачи в новом потоке, а затем ожидает эту сопрограмму.

Он передает два аргумента, в данном случае целое число и строку.

Сопрограмма `main()` приостанавливается, а новая сопрограмма запускается, запускает поток и выполняет блокирующую функцию в новом потоке. Эта сопрограмма тоже затем блокируется.

Блокирующая функция запускается, выводит свое сообщение, переходит в режим сна, а затем выводит свое последнее сообщение.

Новая сопрограмма завершается, а сопрограмма `main()` возобновляет работу и завершает программу asyncio.

Это показывает, как мы можем передавать аргументы блокирующей функции, выполняемой в новом потоке.

```bash
task is running with 100 and TEST
task is done
```

Далее давайте рассмотрим пример блокирующего вызова, который возвращает значение в новом потоке.

## Запуск блокирующей функции с возвращаемым значением в новом потоке

Мы можем изучить, как выполнить блокирующий вызов в новом потоке, который возвращает значение.

В этом примере мы обновим блокирующую функцию, чтобы она возвращала произвольное значение.

Основная сопрограмма будет ждать завершения задачи блокировки, а затем сообщит возвращаемое значение.

Полный пример приведен ниже.

```python
# SuperFastPython.com
# пример запуска вызова блокирующей функции в asyncio в новом потоке с возвращаемым значением
import time
import asyncio
 
# блокирующая функция
def blocking_task():
    # выводит сообщение
    print('task is running')
    # блокировка
    time.sleep(2)
    # выводит сообщение
    print('task is done')
    # возвращает значение
    return 100
 
# основная корутина
async def main():
    # создать сопрограмму для вызова блокирующей функции
    coro = asyncio.to_thread(blocking_task)
    # выполнить вызов в новом потоке и дождаться результата
    result = await coro
    # выводит результат
    print(f'Got: {result}')
 
# запустить программу asyncio
asyncio.run(main())
```

При выполнении примера сначала создается сопрограмма `main()` и используется она как вход в программу asyncio.

Сопрограмма `main()` запускается и создает сопрограмму для запуска фоновой задачи в новом потоке, а затем ожидает эту сопрограмму, ожидая возвращаемого значения.

Сопрограмма `main()` приостанавливается, а новая сопрограмма запускается, запускает поток и выполняет блокирующую функцию в новом потоке. Эта сопрограмма тоже затем блокируется.

Блокирующая функция запускается, выводит свое сообщение, переходит в режим ожидания, затем выводит свое последнее сообщение, а затем возвращает значение.

Новая сопрограмма завершается, и сопрограмма `main()` возобновляется. Он получает возвращаемое значение и сообщает о нем напрямую.

Это показывает, как мы можем получать и использовать возвращаемые значения из блокирующих функций, выполняемых в новом потоке.

```bash
task is running
task is done
Got: 100
```

Далее давайте посмотрим, как мы можем независимо выполнить блокирующий вызов в новом потоке.
