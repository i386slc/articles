# Добавление к классам

{% hint style="info" %}
Ссылка на оригинальную статью: [Contributing to classiness (in Django)](https://www.b-list.org/weblog/2019/mar/04/class/)

Опубликовано: 4 марта 2019

Автор: [James Bennett](https://www.b-list.org/)
{% endhint %}

Пару недель назад я провел [опрос в Твиттере](https://twitter.com/ubernostrum/status/1096609885213491201), в котором спрашивал людей, использовали ли они когда-либо или рассматривали возможность использования метода `contribute_to_class()`, чтобы написать что-то, что прикрепляется к классу модели Django ORM или подключается к нему, и если да, то что они думают об этом. Был также вариант «не знаю, что это такое», который выиграл с большим отрывом, и я пообещал дать объяснение.

К сожалению, это было примерно в то время, когда я попал в аварию на кухне, из-за которой я на некоторое время полностью не мог пользоваться левой рукой. Полное заживление займет немного больше времени, но это тот момент, когда я снова могу нормально печатать, поэтому пришло время дать объяснение.

Однако сначала мне нужно дать некоторое объяснение объяснению. Оставайтесь со мной, и, надеюсь, это будет иметь смысл в конце.

## Сохранение стиля

Если вы использовали Django или хотя бы прошли несколько вводных руководств по Python, вы, вероятно, написали или видели несколько классов Python. Вот простой пример:

```python
import math

class Circle:
    def __init__(self, center, radius):
        self.center = center
        self.radius = radius

    def area(self):
        return math.pi * (self.radius ** 2)

    def circumference(self):
        return 2 * math.pi * self.radius
```

В нем есть большинство вещей, к которым мы привыкли из классов: у него есть некоторые методы, у него есть некоторые атрибуты, у него есть конструктор, который вы можете вызывать для создания нового экземпляра и передавать аргументы, которые будут влиять на новый экземпляр. Но учебники обычно не углубляются в это и не рассказывают, как Python на самом деле обрабатывает классы. Итак, давайте поработаем над этим.

В приведенном выше классе **Circle** строка `class Circle:` начинает блок, который содержит еще девять строк кода (за которыми следует, предположительно, либо удаление отступа, либо конец файла). Все внутри этого блока выполняется, и результатом является словарь dict, _**представляющий локальное пространство имен этого блока**_. Ключи — это имена вещей, определенных внутри блока, а значения — это… их значения. Например, блок кода для класса **Circle** создаст словарь, содержащий три ключа: `'__init__'`, `'area'` и `'circumference'`.

Затем Python собирает три вещи — имя, данное в начальном операторе **class**, родительские классы (если они есть), включенные в начальный оператор **class**, и словарь **dict**, представляющий пространство имен тела класса, — и передает их в указанном порядке в `type()`. Возвращаемое значение из `type()` привязано к имени класса. Важно отметить, что `type()` не является функцией. Это класс, а именно класс классов: точно так же, как вы вызываете `Circle()` для создания нового экземпляра класса **Circle**, вы вызываете `type()` для создания нового экземпляра класса… класса.

Таким образом, процесс определения класса **Circle** состоит из следующих этапов:

1. Выполняется тело класса и собирается всё из полученного пространства имен классов в словарь **dict**. В данном случае у него будут три упомянутых выше ключа, соответствующих названиям трех определенных методов.
2. Вызывается `type('Circle', (), namespace_dict)`.
3. Привязывается результат к имени **Circle**.

Если вы хотите, вы можете сделать это вручную, создав словарь **dict** вещей, которые нужно поместить в класс, и вызвать `type()`:

```python
>>> import math
>>> def __init__(self, center, radius):
...     self.center = center
...     self.radius = radius
...
>>> def area(self):
...     return math.pi * (self.radius ** 2)
...
>>> def circumference(self):
...     return 2 * math.pi * self.radius
...
>>> Circle = type('Circle', (), {'__init__': __init__, 'area': area, 'circumference': circumference})
>>> Circle
<class '__main__.Circle'>
>>> c = Circle(center=(0, 0), radius=1)
>>> c.area()
3.141592653589793
>>> c.circumference()
6.283185307179586
```

Итак, теперь мы понимаем, как Python обрабатывает определение класса. Но есть еще одна вещь, о которой нам нужно знать, прежде чем мы вернемся к Django.

## Вот так meta

Одна продвинутая — и неправильно понятая, и часто неправильно используемая — функция Python — это то, что называется **«metaclass»**. Идею довольно легко объяснить: _**это способ подключиться к описанному выше процессу и изменить способ создания объектов класса**_.

Ранее в этом посте я описал `__init__()` как конструктор класса, и часто именно так с ним знакомятся новые программисты Python. Хотя различие почти никогда не имеет значения, _**это не совсем правильно**_: создание экземпляра класса в Python на самом деле представляет собой двухэтапный процесс, где сначала будет вызываться метод класса `__new__()`, а затем его метод `__init__()`.

Другими словами, если мы возьмем описанный выше класс **Circle** и сделаем `c = Circle(center=(0, 0), radius=1)`, Python на самом деле сделает примерно следующее:

```python
c = Circle.__new__(Circle, center=(0, 0), radius=1)
c.__init__(center=(0, 0), radius=1)
```
