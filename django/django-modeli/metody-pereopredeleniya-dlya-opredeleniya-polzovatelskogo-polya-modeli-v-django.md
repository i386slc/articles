# Методы переопределения для определения пользовательского поля модели в django

{% hint style="info" %}
Ссылка на оригинальную статью: [Overriding methods for defining custom model field in django](https://stackoverflow.com/questions/41206176/overriding-methods-for-defining-custom-model-field-in-django)

Опубликовано: 18 декабря 2016

Автор: [Mangu Singh Rajpurohit](https://stackoverflow.com/users/2393267/mangu-singh-rajpurohit)
{% endhint %}

## Вопрос

Я пытался определить пользовательское поле модели django в python. Я сослался на документы django по следующему адресу [https://docs.djangoproject.com/en/1.10/howto/custom-model-fields/](https://docs.djangoproject.com/en/1.10/howto/custom-model-fields/). Однако меня смущают следующие методы (которые я разделил на группы в соответствии с моим пониманием):

### Группа 1 (методы в этой группе взаимосвязаны в соответствии с документацией)

1. `__init__()`
2. `deconstruct()`

### Группа 2

1. `db_type()`
2. `rel_db_type()`
3. `get_internal_type()`

Группа 3

1. `from_db_value()`
2. `to_python()`
3. `get_prep_value()`
4. `get_db_prep_value()`
5. `get_db_prep_save()`
6. `value_from_object()`
7. `value_to_string()`

Группа 4

1. `formfield()`

У меня следующие вопросы:

1. Когда используется `deconstruct()`? Документы говорят, что это полезно во время миграции, но это не ясно объяснено. Более того, когда он вызывается?
2. Разница между `db_type()` и `get_internal_type()`
3. Разница между `get_prep_value()` и `get_db_prep_value()`
4. Разница между `value_from_object()` и `value_to_string()`. `value_from_object()` не указан в документах.
5. И `from_db_value()`, и `value_to_string()`, и `to_python()` дают объект python из строки. Тогда почему существуют эти разные методы?

Я знаю, я задал немного длинный вопрос. Но не нашел другого способа лучше задать этот вопрос.

Заранее спасибо.

## Ответ

Я постараюсь ответить на них:

### 1. deconstruct()

#### Когда используется deconstruct()?

Этот метод используется, когда у вас есть экземпляр вашего поля, чтобы воссоздать его на основе аргументов, которые вы только что передали в `__init__`. Как упоминалось в [документации](https://docs.djangoproject.com/en/1.10/howto/custom-model-fields/#field-deconstruction), если вы устанавливаете для аргумента **max\_length** статическое значение в своем методе `__init__`; вам это не нужно для ваших экземпляров. Таким образом, вы можете удалить его в своем методе `deconstruct()`. При этом **max\_length** не будет отображаться в вашем экземпляре, пока вы используете его в своих моделях. Вы можете рассматривать **deconstruct** как последнюю очистку и контрольное место перед использованием вашего поля в модели.

### 2. db\_type() и get\_internal\_type()

#### Разница между db\_type() и get\_internal\_type()

Они оба связаны, но относятся к разным уровням.

Если тип данных вашего пользовательского поля зависит от того, какую БД вы используете, `db_type()` — это место, где вы можете управлять своими элементами. Опять же, как они упоминали в [документации](https://docs.djangoproject.com/en/1.10/howto/custom-model-fields/#custom-database-types), если ваше поле является своего рода значением даты/времени, вы должны/можете проверить, является ли текущая база данных **PostgreSQL** или **MySQL** в этом методе. Потому что в то время как значения даты/времени называются **timestamp** в PostgreSQL, и они называются **datetime** в MySQL.

Метод **get\_internal\_type** представляет собой более высокоуровневую версию `db_type()`. Давайте рассмотрим пример значения даты/времени: если вы не хотите проверять и контролировать каждый тип данных, принадлежащий разным базам данных, вы можете наследовать тип данных своего пользовательского поля из встроенных полей Django. Вместо того, чтобы проверять, должно ли это быть **datetime** или **timestamp**; вы можете просто вернуть **DateField** в свой метод **get\_internal\_type**. Как упоминалось в документах, если вы уже создали метод **db\_type**, в большинстве случаев вам не нужен метод **get\_internal\_type**.

### 3. get\_prep\_value() и get\_db\_prep\_value()

#### Разница между get\_prep\_value() и get\_db\_prep\_value()

Эти методы также используют _**почти**_ одинаковую логику между `db_type()` и `get_internal_type()`. Прежде всего, оба эти метода предназначены для преобразования значений db в объекты python. Но, как и в методе **db\_type**, `get_db_prep_value()` обозначает типы полей, специфичные для backend части.

### 4. value\_from\_object() и value\_to\_string()

#### Разница между value\_from\_object() и value\_to\_string(). value\_from\_object() не указан в документации

Из документации:

> Чтобы настроить сериализацию значений сериализатором, вы можете переопределить value\_to\_string(). Использование value\_from\_object() — лучший способ получить значение поля перед сериализацией.

Итак, на самом деле нам не нужен **value\_from\_object**, как задокументировано. Этот метод используется для получения исходного значения поля перед сериализацией. Получите значение с помощью этого метода и настройте его сериализацию в методе **value\_to\_string**. Они даже помещают пример кода в [документации](https://docs.djangoproject.com/en/1.10/howto/custom-model-fields/#converting-field-data-for-serialization)

### 5. from\_db\_value(), value\_to\_string() и to\_python()

#### И from\_db\_value(), и value\_to\_string(), и to\_python() дают объект python из строки. Тогда почему существуют эти разные методы?

В то время как `to_python()` преобразует значение поля в допустимый объект Python, `value_to_string()` преобразует значения поля в строку с вашей пользовательской сериализацией. Они обозначают разные рабочие места.

И **from\_db\_value** преобразует значение, возвращаемое базой данных, в объект Python. На самом деле никогда не слышал об этом. Но проверьте [эту часть](https://docs.djangoproject.com/en/1.10/ref/models/fields/#django.db.models.Field.from\_db\_value) из документации:

> Этот метод не используется для большинства встроенных полей, так как серверная часть базы данных уже возвращает правильный тип Python или сама выполняет преобразование.

## Вопрос (продолжение)

Тем не менее, первый ответ не ясен, когда вызывается `deconstruct()`. Более того, `get_prep_value()` и `get_db_prep_value()` также вводят в заблуждение, поскольку в документации говорится, что они используются для преобразования значений из типов python в тип dbcolumn.

## Ответ 2

Как уже упоминалось, этот ответ вводит в заблуждение. **get\_prep\_value** и **get\_db\_prep\_value** преобразуют из Python в значение базы данных, а не наоборот.
