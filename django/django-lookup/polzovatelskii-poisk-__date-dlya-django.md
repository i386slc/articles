# Пользовательский поиск \_\_date для Django

{% hint style="info" %}
Ссылка на оригинальную статью: [A custom \_\_date lookup for Django](https://bradmontgomery.net/blog/custom-\_\_date-lookup-django/)

Опубликовано: 18 октября 2015

Автор:&#x20;
{% endhint %}

{% hint style="warning" %}
Django 1.9 теперь включает [встроенный поиск по \_\_date](https://docs.djangoproject.com/en/1.9/ref/models/querysets/#date). Если возможно, вам следует использовать его вместо приведенного ниже кода, который не поддерживает часовые пояса.
{% endhint %}

В своем посте о [поиске по дате на прошлой неделе](https://bradmontgomery.net/blog/date-lookups-django/) я закончил обещанием взглянуть на создание [собственного поиска в django](https://docs.djangoproject.com/en/1.8/howto/custom-lookups/) (а именно, поиск по `__date`). Django включает в себя базовый класс **Lookup**, и для создания собственных выражений поиска все, что вам действительно нужно сделать, это:

1. Подкласс `django.db.models.Lookup`
2. Определить атрибут `lookup_name`
3. Написать метод `as_sql`, чтобы определить, как ваша база данных должна обрабатывать построение запроса

Как и обещал, вот небольшой пример. Предположим, у нас есть следующая модель (глупая, но простая). В целях иллюстрации у него есть **DateField** и **DateTimeField**. Мы построим наш поиск так, чтобы он работал с обоими полями.

```python
from django.db import models

class Meeting(models.Model):
    date = models.DateField()
    scheduled = models.DateTimeField()
```

**Шаг 1**. Давайте создадим поиск, который я назову **DateLookup**.

```python
from django.db.models import Lookup

class DateLookup(Lookup):
    """Пользовательский поиск, позволяющий запрашивать DateField
    и DateTimeFields по дате."""

    # Это позволяет нам использовать __date='2015-10-18' в запросе.
    lookup_name = 'date'

    def as_sql(self, compiler, connection):
        # Левая часть (lhs) в предложении WHERE запроса.
        # Она состоит из имени вашего приложения и имени поля.
        # Например '"myapp"."по расписанию"'
        # В нашем случае левая часть не имеет параметров.
        lhs, lhs_params = self.process_lhs(compiler, connection)

        # Правая часть (rhs) + ее параметры будут определять входные данные,
        # используемые в предложении WHERE запроса. На этом этапе rhs_params
        # будет объектом datetime, например: datetime(2015, 10, 18, 0, 0, tzinfo=)
        rhs, rhs_params = self.process_rhs(compiler, connection)

        # И в PostgreSQL, и в MySQL есть функция DATE, которая позволяет нам
        # делать запросы по дате. Предложение WHERE в сгенерированном SQL
        # будет выглядеть примерно так: WHERE DATE(scheduled) = '2015-10-18'
        params = lhs_params + rhs_params
        return 'DATE(%s) = %s' % (lhs, rhs), params
```

**Шаг 2**. Зарегистрируйте его в соответствующих полях модели. В этом случае и **DateField**, и **DateTimeField**.

Документы Django содержат важное примечание о регистрации пользовательских поисков:

```python
from django.db.models.fields import DateField, DateTimeField

DateField.register_lookup(DateLookup)
DateTimeField.register_lookup(DateLookup)
```

{% hint style="info" %}
Вам необходимо убедиться, что эта регистрация произошла, прежде чем пытаться создать с ее помощью какие-либо наборы запросов. Вы можете поместить реализацию в файл `models.py` или зарегистрировать поиск в методе `ready()` **AppConfig**.
{% endhint %}

Теперь откройте оболочку django и вы можете выполнить запрос, подобный следующему, который запрашивает поле даты. Это должно дать вам все собрания **Meeting**, где `date = datetime.date(2015, 10, 18)`:

```python
Meeting.objects.filter(date__date='2015-10-18')
```

Или вы можете сделать следующее: запросить поле даты и времени, которое должно предоставить вам все собрания, в которых столбец **scheduled** включает 18 октября 2015 г.

```python
Meeting.objects.filter(scheduled__date='2015-10-18')
```

Пользовательский поиск в Django — это еще не все, и я настоятельно рекомендую прочитать [документацию по пользовательскому поиску](https://docs.djangoproject.com/en/1.8/howto/custom-lookups/), поскольку там также есть действительно отличный пример.

Примечание. Весь код в этом посте был написан с использованием Python 3.4 и Django 1.8.

## Комментарии

1. Кстати, в Django 1.9 был реализован встроенный поиск `__date`. Имейте в виду, что хотя описанная здесь реализация будет _работать_ на Django 1.7 и 1.8, она не учитывает часовой пояс и вернет неверные результаты, как только `USE_TZ = True` и текущий часовой пояс не UTC.
2. Да, это было! Этот пост был написан всего за несколько дней до выхода версии 1.9, и я усмехнулся, когда увидел поиск по `__date`. Я хотел, чтобы этот пост был в основном иллюстративным, но ваша точка зрения на часовые пояса вполне понятна. Скоро я добавлю обновление/отказ от ответственности. Спасибо!
3. Я думаю, что в большинстве случаев использование функции в левой части предиката SQL не позволяет БД эффективно использовать индексы. Возможно, вы захотите преобразовать его во что-то вроде `... WHERE (the_column >= datetime_of_start_of_day AND the_column < datetime_of_start_of_next_day)`, что в большинстве случаев позволит лучше использовать индексы. Конечно, YMMV, и он может вам не понадобиться, а `DATE` может обрабатываться некоторыми движками специально. Не забывайте всегда `EXPLAIN`:)
4. Это, безусловно, хороший момент! Забавно, я вообще нигде не использовал это в производстве, поэтому понятия не имею о производительности. Было бы интересно проверить вашу теорию на реальных данных и посмотреть, как она работает.
