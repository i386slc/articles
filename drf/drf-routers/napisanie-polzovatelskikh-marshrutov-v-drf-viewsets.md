# Написание пользовательских маршрутов в DRF Viewsets

{% hint style="info" %}
Ссылка на оригинальную статью: [Writing Custom Routes in Django RestFrameWork (DRF) Viewsets](https://dev.to/chukwunazaekpere/writing-custom-routes-in-django-restframework-drf-viewsets-3pj1)

Опубликовано: 1 декабря 2021

Автор: [Chukwunazaekpere](https://dev.to/chukwunazaekpere)
{% endhint %}

Django RestFrameWork (DRF) оказалась самой ценной и полезной библиотекой для Django. Его возможности набора представлений — замечательный ресурс, позволяющий бэкэнд-разработчикам определять надежные URL-адреса со встроенными структурами маршрутов. Эти маршруты потребовали бы, чтобы вы написали уникальный URL-адрес; но благодаря находчивому контексту наборов представлений из DRF. Я хотел бы поделиться некоторыми полезными идеями, чтобы использовать ваше использование DRF. Это будет классифицироваться по следующим признакам:

1. декораторы
2. пользовательские маршруты

Тогда приступим. Теперь, давайте возьмем, например, URL-адрес аутентификации, функции, которые вы определенно хотели бы включить, будут включать, но определенно не ограничиваться следующим:

1. signup
2. signin
3. forgot password

Лично я бы включил больше маршрутов (в соответствии с наследием или правилами Django: явное лучше, чем неявное);

1. OTP
2. user-detail

У вас могут быть некоторые другие, которые вы хотели бы включить, при условии, что они подпадают под коллективное действие аутентификации и авторизации.

Теперь возникает вопрос: не было бы громоздко, если бы вам пришлось написать уникальное представление, а затем определить уникальный URL-адрес для всех этих действий аутентификации? определенно, это было бы (мне не нужно говорить).

Вот что помогают нам решить наборы представлений DRF; и, как следует из названия, «наборы представлений». Ты понял?

Конечно, вы сделали. Давайте тогда определим API, используя наборы представлений DRF. Я разделю процедуры, как показано ниже;

## I. Начало нового проекта

Я предполагаю, что вы знакомы с рекомендациями django по запуску нового проекта, т. е. созданию виртуальной среды, определению файлов **env** и т. д. Во-вторых, структура папок для недавно созданного приложения в django поставляется с файлом `views.py`. Вы можете переименовать его в `viewsets.py`.

## II. Определите класс Viewset для пользователей

(скажем, **пользователи** - это приложение в вашем проекте django):

```python
from rest_framework import viewsets, status
# предполагаем, что вы также определили сериализатор
from .serializers import UsersSerilizer
# скажем, у вас есть модель пользователей
from .models import Users
from rest_framework.decorators import action
from rest_framework.response import Response

class UsersViewSets(viewsets.ModelViewSet):
    # переменная queryset обязательна
    queryset = Users.objects.all()
    serializer_class = UsersSerializer 
    permission_classes = []

    # ----- для создания нового пользователя
    def create(self, request, *args, **kwargs):
        super().create(request, *args, **kwargs)

    # ----- для вывода списка всех пользователей
    def list(self, request, *args, **kwargs):
        super().list(request, *args, **kwargs)

    # ----- для обновления пользователя
    def update(self, request, *args, **kwargs):
        super().update(request, *args, **kwargs)

    @action(methods=["POST"], detail=False, url_path="forgot-password")
    def forgot_password(self, *args, **kwargs):
        #... логика
        return Response(
            data=<whatever data>, status=status.HTTP_201_CREATED,
            content_type="application/json"
        )
```

Из приведенного выше кода очевидно, что ключевое слово **super** относится к методам суперкласса; что означает, что вы можете переопределить эти методы в соответствии с требованиями вашего варианта использования приложения. Однако, глядя на четвертый метод, его структура выглядит иначе, чем у других. Это метод, определяющий пользовательский URL: forgot password.

Символ **@** обозначает синтаксис декоратора (функция; вы можете прочитать о декораторах в питоне). Это процедура для сообщения DRF о том, что вы хотите определить собственный URL-адрес; потому что методов по умолчанию будет недостаточно.

Аргументы включают:

* **methods**: какой HTTP-глагол выполняет этот URL-адрес?
* **detail**: логическое значение; сообщающее DRF, является ли это подробным маршрутом detail, т. е. если для построения маршрута потребуется первичный ключ, уникальный адрес электронной почты и т. д., чтобы вернуть конкретный экземпляр.
* **url\_path**: как бы вы хотели назвать этот маршрут?

С приведенной выше конфигурацией вы также можете включить представление **otp-verification** (просто говоря), обработать бизнес-логику и вернуть ответ (как всегда). Следующим шагом является регистрация этого набора представлений, чтобы приложение могло его распознать.

## III. Определите файл routers.py

это файл, из которого мы регистрируем все наборы представлений в приложении, т. е. у вас могут быть **product\_viewsets**, **authentication\_viewsets**, **finance\_viewsets** и т. д. Вы должны зарегистрировать набор представлений следующим образом:

```python
from rest_framework import routers
app_router = routers.DefaultRouter()

# импорт viewsets из различных модулей приложения
from users import viewsets as users_viewsets

# регистрация свои маршрутизаторов как 
app_router.register(
    "auth or whatever you prefer (avoid trailing slashes)",
    users_viewsets.UsersViewSet,
    basename="auth"
)
#... другие viewsets регистрации
```

Этот файл `router.py` должен находиться в том же каталоге, что и файл приложения `urls.py`.

## IV. Подключение файла router.py к файлу urls.py приложений:

наконец, в файле `urls.py` приложений зарегистрируйте файл `router.py` следующим образом:

```python
from .router import app_router
from django.urls import path, include

urlpatterns = [
    path("your-site/", include(app_router.urls), 
]
```

поэтому мы можем ссылаться на наш пользовательский маршрут как:

```
# для локального сервера. Не забывайте, что https в производстве.
http://localhost:8000/your-site/auth/forgot-password
```

Дайте мне знать, если есть места, где вы обнаружите нестыковки. Спасибо.
